#include "tinyexpr.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include <complex.h>
#include <stdio.h>
#define NUMEQ  30
#define NUMVAR 16
 
double solution[] ={16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0 };
char* str_replace(char  string[] , const char* substr, const char  replacement[]) {
	char* tok = NULL;
	char* newstr = NULL;
	char* oldstr = NULL;
	int   oldstr_len = 0;
	int   substr_len = 0;
	int   replacement_len = 0;

	newstr = strdup(string);
	substr_len = strlen(substr);
	replacement_len = strlen(replacement);

	if (substr == NULL || replacement == NULL) {
		return newstr;
	}

	while ((tok = strstr(newstr, substr))) {
		oldstr = newstr;
		oldstr_len = strlen(oldstr);
		newstr = (char*)malloc(sizeof(char) * (oldstr_len - substr_len + replacement_len + 1));

		if (newstr == NULL) {
			free(oldstr);
			return NULL;
		}

		memcpy(newstr, oldstr, tok - oldstr);
		memcpy(newstr + (tok - oldstr), replacement, replacement_len);
		memcpy(newstr + (tok - oldstr) + replacement_len, tok + substr_len, oldstr_len - substr_len - (tok - oldstr));
		memset(newstr + oldstr_len - substr_len + replacement_len, 0, 1);

		free(oldstr);
	}
	//free(string);
	return newstr;
}

 char   **new_str3;
char   **new_str2;
int newloop = 0;
char search[1000][1000] = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q"};
char ** fill_equation(char * line_buf, double ** data , int lll,char *  str[],char * str2[] )
{
	char strnew[1000][1000];
	char new_str[1000][1000];
  	char buf1[1000][1000];
 	char buf2[1000][1000];
 	char buf3[1000][1000];

	strcpy(new_str2[lll] , line_buf);

	for(int ll = 0; ll < 16; ll++)
	{			 			
		char * ptr = strstr(  &new_str2[lll][ll]   , search[ll]);
		if (ptr != NULL) /* Substring found */
		{
			sprintf(  buf1[lll]   ,"%f" ,data[lll][ll]  );		
			//printf("eq: =  %s  \n",buf1[ll]) ;
			new_str2[lll]  =  str_replace(   new_str2[lll]  ,search[ll],buf1[lll] );
		}	 
	} 
		 	    
 return new_str2[lll] ;
}

 

#define MAXBUFLEN 44*20000000
double   result[100][1000];
double commonpo;
double po;
int iteratorn = 0;
int main()
{
double a1[NUMEQ+1][16] ={{111,	381.64414414,	13.9549550,	52.72792206,	28305	,111,	381.64414414,	13.9549550,	52.72792206,	28305,	111,	381.64414414,	13.9549550,	52.72792206,	28305	,28305}, 
{19,	127.71052632	,7.60526316,	19.07106781,	4845,	19,	127.71052632	,7.60526316,	19.07106781,	4845,19,	127.71052632	,7.60526316,	19.07106781,	4845,	4845}, 
{10,	120.10000000	,7.40000000	,13.65685425,	2550,	10,	120.10000000	,7.40000000	,13.65685425,	2550,10,	120.10000000	,7.40000000	,13.65685425,	2550,	2550}, 
{58	,335.72413793	,15.89655172	,48.14213562,	14790	,58	,335.72413793	,15.89655172	,48.14213562,	14790,	58	,335.72413793	,15.89655172	,48.14213562,	14790,14790}, 
{12,	354.91666667	,7.91666667,	15.65685425,	3060,	12,	354.91666667	,7.91666667,	15.65685425,	3060,	12,	354.91666667	,7.91666667,	15.65685425,	3060,	3060}, 
{73,	423.19863014	,22.62328767,	72.87005769,	18615,	73,	423.19863014	,22.62328767,	72.87005769,	18615,	73,	423.19863014	,22.62328767,	72.87005769,	18615,	18615}, 
{121,	368.59090909,	17.33471074,	47.89949494,	30855,21,	368.59090909,	17.33471074,	47.89949494,	30855,	21,	368.59090909,	17.33471074,	47.89949494,	30855,	30855}, 
{97,	413.02577320	,13.39690722,	57.11269837	,24735,	97,	413.02577320	,13.39690722,	57.11269837	,24735,97,	413.02577320	,13.39690722,	57.11269837	,24735,	24735}, 
{79,	387.48734177,	17.08227848,	39.89949494,	20145,	79,	387.48734177,	17.08227848,	39.89949494,	20145,	79,	387.48734177,	17.08227848,	39.89949494,	20145,	20145}, 
{124,	109.45967742,	18.13709677,	46.48528137,	31620	,124,	109.45967742,	18.13709677,	46.48528137,	31620,	124,	109.45967742,	18.13709677,	46.48528137,	31620	,31620}, 
{109,	117.44495413,	18.20642202,	42.48528137,	27795,	109,	117.44495413,	18.20642202,	42.48528137,	27795,	109,	117.44495413,	18.20642202,	42.48528137,	27795,	27795}, 
{106,	360.50000000,	18.42452830,	41.89949494	,27030,	106,	360.50000000,	18.42452830,	41.89949494	,27030	,106,	360.50000000,	18.42452830,	41.89949494	,27030,	27030}, 
{49,	392.92857143,	17.84693878,	30.48528137,	12495,	49,	392.92857143,	17.84693878,	30.48528137,	12495,	49,	392.92857143,	17.84693878,	30.48528137,	12495,	12495}, 
{5,	407.50000000,	12.10000000	,11.07106781,	1275,    5,	407.50000000,	12.10000000	,11.07106781,	1275,    5,	407.50000000,	12.10000000	,11.07106781,	1275,	1275} ,
{116,	126.46551724	,18.44827586,	41.07106781,	29580,116,	126.46551724	,18.44827586,	41.07106781,	29580,116,	126.46551724	,18.44827586,	41.07106781,	29580,	29580} ,
{117,	352.02136752,	19.32051282,	42.48528137,	29835,117,	352.02136752,	19.32051282,	42.48528137,	29835,117,	352.02136752,	19.32051282,	42.48528137,	29835,	29835} ,
{90,	418.15555556	,25.55555556	,60.04163056,	22950,90,	418.15555556	,25.55555556	,60.04163056,	22950,90,	418.15555556	,25.55555556	,60.04163056,	22950,	22950} ,
{66	,150.00000000	,18.50000000,	31.65685425,	16830,66	,150.00000000	,18.50000000,	31.65685425,	16830,66	,150.00000000	,18.50000000,	31.65685425,	16830,	16830} ,
{83,	157.53614458,	18.93373494	,35.07106781	,21165,83,	157.53614458,	18.93373494	,35.07106781	,21165,83,	157.53614458,	18.93373494	,35.07106781	,21165,	21165} ,
{117	,166.98717949,	19.14102564	,41.89949494,	29835,117	,166.98717949,	19.14102564	,41.89949494,	29835,117	,166.98717949,	19.14102564	,41.89949494,	29835,	29835} ,
{65	,344.50000000	,19.50000000,	33.65685425,	16575,65	,344.50000000	,19.50000000,	33.65685425,	16575,65	,344.50000000	,19.50000000,	33.65685425,	16575,	16575} ,
{39,	397.91025641	,18.37179487	,25.89949494,	9945,39,	397.91025641	,18.37179487	,25.89949494,	9945,39,	397.91025641	,18.37179487	,25.89949494,	9945,	9945} ,
{48	,175.00000000,	20.00000000	,29.65685425,	12240,48	,175.00000000,	20.00000000	,29.65685425,	12240,48	,175.00000000,	20.00000000	,29.65685425,	12240,	12240} ,
{60,	180.50000000	,20.00000000	,31.65685425,	15300,60,	180.50000000	,20.00000000	,31.65685425,	15300,60,	180.50000000	,20.00000000	,31.65685425,	15300,	15300} ,
{58,	186.44827586,	20.18965517	,30.48528137,	14790,58,	186.44827586,	20.18965517	,30.48528137,	14790,	58,	186.44827586,	20.18965517	,30.48528137,	14790,	14790} ,
{62,	315.51612903	,20.59677419,	32.48528137	,15810,	62,	315.51612903	,20.59677419,	32.48528137	,15810,	62,	315.51612903	,20.59677419,	32.48528137	,15810,	15810} ,
{54	,321.16666667,	20.66666667	,32.48528137,	13770,54	,321.16666667,	20.66666667	,32.48528137,	13770,54	,321.16666667,	20.66666667	,32.48528137,	13770	,13770} ,
{48	,326.25000000,	20.00000000	,30.48528137,	12240,48	,326.25000000,	20.00000000	,30.48528137,	12240,48	,326.25000000,	20.00000000	,30.48528137,	12240	,12240} ,
{49	,331.39795918,	20.11224490,	31.89949494,	12495,49	,331.39795918,	20.11224490,	31.89949494,	12495,49	,331.39795918,	20.11224490,	31.89949494,	12495	,12495} ,
{105	,194.58571429,	20.84285714,	39.07106781	,26775	,105	,194.58571429,	20.84285714,	39.07106781	,26775	,105	,194.58571429,	20.84285714,	39.07106781	,26775	,26775}};
		FILE *fp5;	
		char* filename = "../datad.txt";
		fp5 = fopen(filename, "r");
	 
		if (fp5 == NULL  ){
			printf("Could not open file %s",filename);
			return 1;
		}

	 	char * line_buf = NULL;
	 	size_t line_buf_size = 0;
		int line_count = 0;
		ssize_t * line_size;

		line_size = malloc(   MAXBUFLEN );	 
	 	   
	 	double **VARA1;
		VARA1 = malloc( 100*32);
	 
  		for(int iiiii=0; iiiii<200*1; iiiii++)
			VARA1[iiiii] =  malloc(1233);
	
		new_str2 = malloc( 12311);
	 
  		for(int iiiii=0; iiiii<NUMEQ+1; iiiii++)
			new_str2[iiiii] =  malloc(12311);



		new_str3 = malloc( 123);
	 
  		for(int iiiii=0; iiiii<NUMEQ+1; iiiii++)
			new_str3[iiiii] =  malloc(123);
		double inc  = 0;
		int counter = 0;

	 
	while(line_size >= 0 && line_count < 600000000)
	{
			line_size[line_count] = getline(  &line_buf  , &line_buf_size, fp5);	
	        for(int kkkk = 0; kkkk < NUMEQ; kkkk++)
		{ 

			int goaway = 0;
			int  oooo ;
			for(oooo = 0; oooo < NUMEQ; oooo++)
			{  		 
				 //printf("iteratorn =%d \n", iteratorn);
				 
				 double fpos =   INFINITY;
				 double fneg =  -INFINITY;

				 for(int kkk = 0; kkk < NUMVAR; kkk++)
				 { 
					  VARA1[oooo][kkk] = a1[oooo][kkk];
				 
				 }				
			  	 new_str2[oooo] = fill_equation(line_buf,VARA1 ,oooo,0,0);
			 	//   printf("eq: =  %s  \n",new_str2[oooo]) ;		 
				 result[oooo][0] = te_interp(new_str2[oooo], 0);
				 if(  isnan(result[oooo][0])  != 0  ||  (result[oooo][0] >  100000) || (result[oooo][0]<  0)   || (result[oooo][0] == 0) || result[oooo][0] ==  fpos  || result[oooo][0] ==  fneg  )
				 {					 
					 break;
				 }

		if(oooo == 15)	
			goaway =1;	
		}
	if(goaway == 1)
		break;

//printf("kkkk =%d \n", kkkk);
}	 
 
		if(iteratorn % 1000 ==0)
			printf("%d\n",iteratorn  ) ;			
		// printf("  %f \n", result[0][0] ) ;	
		commonpo = 0;
		po = 0;
		int oooo;
		for(  oooo = 0; oooo < NUMEQ; oooo++)
		{ 
			  commonpo  =commonpo + result[oooo][0];		 
 		 	  //printf("eq: =  %f  \n",result[oooo][0]) ;
			  //printf("commonpo: =  %f  \n",commonpo) ;			
		}
		//printf("eq: =  %s  \n",new_str2[0]) ;
		po =  commonpo/30.0;
	  	//  printf("po2: =  %.10f  %.10f \n",po,result[4][0]) ;
		//sleep(1);
 		//sleep(1);
 
 		  if(fabs((result[0][0]))- po > 1.0 &&  ((result[0][0])  - po < 3.0))
		   if(fabs((result[1][0]))- po > 1.0 &&  ((result[1][0])  - po < 3.0))
		   if(fabs((result[2][0]))- po > 1.0 &&  ((result[2][0])  - po < 3.0)) 
		{
		  	 for(  oooo = 0; oooo < NUMEQ; oooo++)	
			 	 printf("eq: =  %s  :: %f \n",new_str2[oooo], result[oooo][0] ) ;
 
		}
iteratorn++;
}
}
